[
  {
    "Text": "u.UniqueIndex(\n                conv =>",
    "Start": 24968,
    "Length": 38,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    internal abstract partial class ConversionsBase\n    {\n        /// <remarks>\n        /// NOTE: Keep this method in sync with AnalyzeImplicitUserDefinedConversionForSwitchGoverningType.\n        /// </remarks>\n        private UserDefinedConversionResult AnalyzeImplicitUserDefinedConversions(\n            BoundExpression sourceExpression,\n            TypeSymbol source,\n            TypeSymbol target,\n            ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            Debug.Assert(sourceExpression != null || (object)source != null);\n            Debug.Assert((object)target != null);\n\n            // User-defined conversions that involve generics can be quite strange. There\n            // are two basic problems: first, that generic user-defined conversions can be\n            // \"shadowed\" by built-in conversions, and second, that generic user-defined\n            // conversions can make conversions that would never have been legal user-defined\n            // conversions if declared non-generically. I call this latter kind of conversion\n            // a \"suspicious\" conversion.\n            //\n            // The shadowed conversions are easily dealt with:\n            //\n            // SPEC: If a predefined implicit conversion exists from a type S to type T,\n            // SPEC: all user-defined conversions, implicit or explicit, are ignored.\n            // SPEC: If a predefined explicit conversion exists from a type S to type T,\n            // SPEC: any user-defined explicit conversion from S to T are ignored.\n            //\n            // The rule above can come into play in cases like:\n            //\n            // sealed class C<T> { public static implicit operator T(C<T> c) { ... } }\n            // C<object> c = whatever;\n            // object o = c;\n            //\n            // The built-in implicit conversion from C<object> to object must shadow\n            // the user-defined implicit conversion.\n            //\n            // The caller of this method checks for user-defined conversions *after*\n            // predefined implicit conversions, so we already know that if we got here,\n            // there was no predefined implicit conversion. \n            //\n            // Note that a user-defined *implicit* conversion may win over a built-in\n            // *explicit* conversion by the rule given above. That is, if we created\n            // an implicit conversion from T to C<T>, then the user-defined implicit \n            // conversion from object to C<object> could be valid, even though that\n            // would be \"replacing\" a built-in explicit conversion with a user-defined\n            // implicit conversion. This is one of the \"suspicious\" conversions,\n            // as it would not be legal to declare a user-defined conversion from\n            // object in a non-generic type.\n            //\n            // The way the native compiler handles suspicious conversions involving\n            // interfaces is neither sensible nor in line with the rules in the \n            // specification. It is not clear at this time whether we should be exactly\n            // matching the native compiler, the specification, or neither, in Roslyn.\n\n            // Spec (6.4.4 User-defined implicit conversions)\n            //   A user-defined implicit conversion from an expression E to type T is processed as follows:\n\n            // SPEC: Find the set of types D from which user-defined conversion operators...\n            var d = ArrayBuilder<NamedTypeSymbol>.GetInstance();\n            ComputeUserDefinedImplicitConversionTypeSet(source, target, d, ref useSiteDiagnostics);\n\n            // SPEC: Find the set of applicable user-defined and lifted conversion operators, U...\n            var ubuild = ArrayBuilder<UserDefinedConversionAnalysis>.GetInstance();\n            ComputeApplicableUserDefinedImplicitConversionSet(sourceExpression, source, target, d, ubuild, ref useSiteDiagnostics);\n            d.Free();\n            ImmutableArray<UserDefinedConversionAnalysis> u = ubuild.ToImmutableAndFree();\n\n            // SPEC: If U is empty, the conversion is undefined and a compile-time error occurs.\n            if (u.Length == 0)\n            {\n                return UserDefinedConversionResult.NoApplicableOperators(u);\n            }\n\n            // SPEC: Find the most specific source type SX of the operators in U...\n            TypeSymbol sx = MostSpecificSourceTypeForImplicitUserDefinedConversion(u, source, ref useSiteDiagnostics);\n            if ((object)sx == null)\n            {\n                return UserDefinedConversionResult.NoBestSourceType(u);\n            }\n\n            // SPEC: Find the most specific target type TX of the operators in U...\n            TypeSymbol tx = MostSpecificTargetTypeForImplicitUserDefinedConversion(u, target, ref useSiteDiagnostics);\n            if ((object)tx == null)\n            {\n                return UserDefinedConversionResult.NoBestTargetType(u);\n            }\n\n            int? best = MostSpecificConversionOperator(sx, tx, u);\n            if (best == null)\n            {\n                return UserDefinedConversionResult.Ambiguous(u);\n            }\n\n            return UserDefinedConversionResult.Valid(u, best.Value);\n        }\n\n        private static void ComputeUserDefinedImplicitConversionTypeSet(TypeSymbol s, TypeSymbol t, ArrayBuilder<NamedTypeSymbol> d, ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            // Spec 6.4.4: User-defined implicit conversions\n            //   Find the set of types D from which user-defined conversion operators\n            //   will be considered. This set consists of S0 (if S0 is a class or struct),\n            //   the base classes of S0 (if S0 is a class), and T0 (if T0 is a class or struct).\n\n            TypeSymbol s0 = GetUnderlyingEffectiveType(s, ref useSiteDiagnostics);\n            TypeSymbol t0 = GetUnderlyingEffectiveType(t, ref useSiteDiagnostics);\n\n            AddTypesParticipatingInUserDefinedConversion(d, s0, includeBaseTypes: true, useSiteDiagnostics: ref useSiteDiagnostics);\n            AddTypesParticipatingInUserDefinedConversion(d, t0, includeBaseTypes: false, useSiteDiagnostics: ref useSiteDiagnostics);\n        }\n\n        /// <summary>\n        /// This method find the set of applicable user-defined and lifted conversion operators, u.\n        /// The set consists of the user-defined and lifted implicit conversion operators declared by\n        /// the classes and structs in d that convert from a type encompassing source to a type encompassed by target.\n        /// However if allowAnyTarget is true, then it considers all operators that convert from a type encompassing source\n        /// to any target. This flag must be set only if we are computing user defined conversions from a given source\n        /// type to any target type.\n        /// </summary>\n        /// <remarks>\n        /// Currently allowAnyTarget flag is only set to true by AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,\n        /// where we must consider user defined implicit conversions from the type of the switch expression to\n        /// any of the possible switch governing types.\n        /// </remarks>\n        private void ComputeApplicableUserDefinedImplicitConversionSet(\n            BoundExpression sourceExpression,\n            TypeSymbol source,\n            TypeSymbol target,\n            ArrayBuilder<NamedTypeSymbol> d,\n            ArrayBuilder<UserDefinedConversionAnalysis> u,\n            ref HashSet<DiagnosticInfo> useSiteDiagnostics,\n            bool allowAnyTarget = false)\n        {\n            Debug.Assert(sourceExpression != null || (object)source != null);\n            Debug.Assert(((object)target != null) == !allowAnyTarget);\n            Debug.Assert(d != null);\n            Debug.Assert(u != null);\n\n            // SPEC: Find the set of applicable user-defined and lifted conversion operators, U.\n            // SPEC: The set consists of the user-defined and lifted implicit conversion operators\n            // SPEC: declared by the classes and structs in D that convert from a type encompassing\n            // SPEC: E to a type encompassed by T. If U is empty, the conversion is undefined and\n            // SPEC: a compile-time error occurs.\n\n            // SPEC: Give a user-defined conversion operator that converts from a non-nullable\n            // SPEC: value type S to a non-nullable value type T, a lifted conversion operator\n            // SPEC: exists that converts from S? to T?.\n\n            // DELIBERATE SPEC VIOLATION:\n            //\n            // The spec here essentially says that we add an applicable \"regular\" conversion and \n            // an applicable lifted conversion, if there is one, to the candidate set, and then\n            // let them duke it out to determine which one is \"best\".\n            //\n            // This is not at all what the native compiler does, and attempting to implement\n            // the specification, or slight variations on it, produces too many backwards-compatibility\n            // breaking changes.\n            //\n            // The native compiler deviates from the specification in two major ways here.\n            // First, it does not add *both* the regular and lifted forms to the candidate set.\n            // Second, the way it characterizes a \"lifted\" form is very, very different from\n            // how the specification characterizes a lifted form. \n            //\n            // An operation, in this case, X-->Y, is properly said to be \"lifted\" to X?-->Y? via\n            // the rule that X?-->Y? matches the behavior of X-->Y for non-null X, and converts\n            // null X to null Y otherwise.\n            //\n            // The native compiler, by contrast, takes the existing operator and \"lifts\" either\n            // the operator's parameter type or the operator's return type to nullable. For\n            // example, a conversion from X?-->Y would be \"lifted\" to X?-->Y? by making the\n            // conversion from X? to Y, and then from Y to Y?.  No \"lifting\" semantics\n            // are imposed; we do not check to see if the X? is null. This operator is not\n            // actually \"lifted\" at all; rather, an implicit conversion is applied to the \n            // output. **The native compiler considers the result type Y? of that standard implicit\n            // conversion to be the result type of the \"lifted\" conversion**, rather than\n            // properly considering Y to be the result type of the conversion for the purposes \n            // of computing the best output type.\n            //\n            // MOREOVER: the native compiler actually *does* implement nullable lifting semantics\n            // in the case where the input type of the user-defined conversion is a non-nullable\n            // value type and the output type is a nullable value type **or pointer type, or \n            // reference type**. This is an enormous departure from the specification; the\n            // native compiler will take a user-defined conversion from X-->Y? or X-->C and \"lift\"\n            // it to a conversion from X?-->Y? or X?-->C that has nullable semantics.\n            // \n            // This is quite confusing. In this code we will classify the conversion as either\n            // \"normal\" or \"lifted\" on the basis of *whether or not special lifting semantics\n            // are to be applied*. That is, whether or not a later rewriting pass is going to\n            // need to insert a check to see if the source expression is null, and decide\n            // whether or not to call the underlying unlifted conversion or produce a null\n            // value without calling the unlifted conversion.\n\n            // DELIBERATE SPEC VIOLATION (See bug 17021)\n            // The specification defines a type U as \"encompassing\" a type V\n            // if there is a standard implicit conversion from U to V, and\n            // neither are interface types.\n            //\n            // The intention of this language is to ensure that we do not allow user-defined\n            // conversions that involve interfaces. We have a reasonable expectation that a\n            // conversion that involves an interface is one that preserves referential identity,\n            // and user-defined conversions usually do not.\n            //\n            // Now, suppose we have a standard conversion from Alpha to Beta, a user-defined\n            // conversion from Beta to Gamma, and a standard conversion from Gamma to Delta.\n            // The specification allows the implicit conversion from Alpha to Delta only if \n            // Beta encompasses Alpha and Delta encompasses Gamma.  And therefore, none of them\n            // can be interface types, de jure.\n            //\n            // However, the dev10 compiler only checks Alpha and Delta to see if they are interfaces,\n            // and allows Beta and Gamma to be interfaces. \n            //\n            // So what's the big deal there? It's not legal to define a user-defined conversion where\n            // the input or output types are interfaces, right?\n            //\n            // It is not legal to define such a conversion, no, but it is legal to create one via generic\n            // construction. If we have a conversion from T to C<T>, then C<I> has a conversion from I to C<I>.\n            //\n            // The dev10 compiler fails to check for this situation. This means that, \n            // you can convert from int to C<IComparable> because int implements IComparable, but cannot\n            // convert from IComparable to C<IComparable>!\n            //\n            // Unfortunately, we know of several real programs that rely upon this bug, so we are going\n            // to reproduce it here.\n\n            if ((object)source != null && source.IsInterfaceType() || (object)target != null && target.IsInterfaceType())\n            {\n                return;\n            }\n\n            foreach (NamedTypeSymbol declaringType in d)\n            {\n                foreach (MethodSymbol op in declaringType.GetOperators(WellKnownMemberNames.ImplicitConversionName))\n                {\n                    // We might have a bad operator and be in an error recovery situation. Ignore it.\n                    if (op.ReturnsVoid || op.ParameterCount != 1)\n                    {\n                        continue;\n                    }\n\n                    TypeSymbol convertsFrom = op.ParameterTypes[0];\n                    TypeSymbol convertsTo = op.ReturnType;\n                    Conversion fromConversion = EncompassingImplicitConversion(sourceExpression, source, convertsFrom, ref useSiteDiagnostics);\n                    Conversion toConversion = allowAnyTarget ? Conversion.Identity :\n                        EncompassingImplicitConversion(null, convertsTo, target, ref useSiteDiagnostics);\n\n                    if (fromConversion.Exists && toConversion.Exists)\n                    {\n                        // There is an additional spec violation in the native compiler. Suppose\n                        // we have a conversion from X-->Y and are asked to do \"Y? y = new X();\"  Clearly\n                        // the intention is to convert from X-->Y via the implicit conversion, and then\n                        // stick a standard implicit conversion from Y-->Y? on the back end. **In this \n                        // situation, the native compiler treats the conversion as though it were\n                        // actually X-->Y? in source for the purposes of determining the best target\n                        // type of an operator.\n                        //\n                        // We perpetuate this fiction here.\n\n                        if ((object)target != null && target.IsNullableType() && convertsTo.IsNonNullableValueType())\n                        {\n                            convertsTo = MakeNullableType(convertsTo);\n                            toConversion = allowAnyTarget ? Conversion.Identity :\n                                EncompassingImplicitConversion(null, convertsTo, target, ref useSiteDiagnostics);\n                        }\n\n                        u.Add(UserDefinedConversionAnalysis.Normal(op, fromConversion, toConversion, convertsFrom, convertsTo));\n                    }\n                    else if ((object)source != null && (object)target != null && source.IsNullableType() && convertsFrom.IsNonNullableValueType() && target.CanBeAssignedNull())\n                    {\n                        // As mentioned above, here we diverge from the specification, in two ways.\n                        // First, we only check for the lifted form if the normal form was inapplicable.\n                        // Second, we are supposed to apply lifting semantics only if the conversion \n                        // parameter and return types are *both* non-nullable value types.\n                        //\n                        // In fact the native compiler determines whether to check for a lifted form on\n                        // the basis of:\n                        //\n                        // * Is the type we are ultimately converting from a nullable value type?\n                        // * Is the parameter type of the conversion a non-nullable value type?\n                        // * Is the type we are ultimately converting to a nullable value type, \n                        //   pointer type, or reference type?\n                        //\n                        // If the answer to all those questions is \"yes\" then we lift to nullable\n                        // and see if the resulting operator is applicable.\n                        TypeSymbol nullableFrom = MakeNullableType(convertsFrom);\n                        TypeSymbol nullableTo = convertsTo.IsNonNullableValueType() ? MakeNullableType(convertsTo) : convertsTo;\n                        Conversion liftedFromConversion = EncompassingImplicitConversion(sourceExpression, source, nullableFrom, ref useSiteDiagnostics);\n                        Conversion liftedToConversion = !allowAnyTarget ?\n                            EncompassingImplicitConversion(null, nullableTo, target, ref useSiteDiagnostics) :\n                            Conversion.Identity;\n                        if (liftedFromConversion.Exists && liftedToConversion.Exists)\n                        {\n                            u.Add(UserDefinedConversionAnalysis.Lifted(op, liftedFromConversion, liftedToConversion, nullableFrom, nullableTo));\n                        }\n                    }\n                }\n            }\n        }\n\n        private TypeSymbol MostSpecificSourceTypeForImplicitUserDefinedConversion(ImmutableArray<UserDefinedConversionAnalysis> u, TypeSymbol source, ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            // SPEC: If any of the operators in U convert from S then SX is S.\n            if ((object)source != null)\n            {\n                if (u.Any(conv => conv.FromType == source))\n                {\n                    return source;\n                }\n            }\n\n            // SPEC: Otherwise, SX is the most encompassed type in the set of\n            // SPEC: source types of the operators in U.\n            return MostEncompassedType(u, conv => conv.FromType, ref useSiteDiagnostics);\n        }\n\n        private TypeSymbol MostSpecificTargetTypeForImplicitUserDefinedConversion(ImmutableArray<UserDefinedConversionAnalysis> u, TypeSymbol target, ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            // SPEC: If any of the operators in U convert to T then TX is T.\n            // SPEC: Otherwise, TX is the most encompassing type in the set of\n            // SPEC: target types of the operators in U. \n\n            // DELIBERATE SPEC VIOLATION:\n            // The native compiler deviates from the specification in the way it \n            // determines what the \"converts to\" type is. The specification is pretty\n            // clear that the \"converts to\" type is the actual return type of the \n            // conversion operator, or, in the case of a lifted operator, the lifted-to-\n            // nullable type. That is, if we have X-->Y then the converts-to type of\n            // the operator in its normal form is Y, and the converts-to type of the \n            // operator in its lifted form is Y?. \n            //\n            // The native compiler does not do this. Suppose we have a user-defined\n            // conversion X-->Y, and the assignment Y? y = new X(); -- the native \n            // compiler will consider the converts-to type of X-->Y to be Y?, surprisingly\n            // enough. \n            //\n            // We have previously written the appropriate \"ToType\" into the conversion analysis\n            // to perpetuate this fiction.\n\n            if (u.Any(conv => conv.ToType == target))\n            {\n                return target;\n            }\n\n            return MostEncompassingType(u, conv => conv.ToType, ref useSiteDiagnostics);\n        }\n\n        private static int LiftingCount(UserDefinedConversionAnalysis conv)\n        {\n            int count = 0;\n            if (conv.FromType != conv.Operator.ParameterTypes[0])\n            {\n                count += 1;\n            }\n\n            if (conv.ToType != conv.Operator.ReturnType)\n            {\n                count += 1;\n            }\n\n            return count;\n        }\n\n        private static int? MostSpecificConversionOperator(TypeSymbol sx, TypeSymbol tx, ImmutableArray<UserDefinedConversionAnalysis> u)\n        {\n            Debug.Assert((object)sx != null);\n            Debug.Assert((object)tx != null);\n\n            // SPEC: If U contains exactly one user-defined conversion operator from SX to TX \n            // SPEC: then that is the most-specific conversion operator;\n            //\n            // SPEC: Otherise, if U contains exactly one lifted conversion operator that converts from\n            // SPEC: SX to TX then this is the most specific operator.\n            //\n            // SPEC: Otherise, the conversion is ambiguous and a compile-time error occurs.\n            //\n            // SPEC ERROR:\n            //\n            // Clearly the text above cannot be correct because it gives undesirable results.\n            // Suppose we have structs E and F with an implicit user defined conversion from \n            // F to E. We have an assignment from F to E?. Clearly what should happen is\n            // we should convert F to E, then convert E to E?.  But the spec says that this\n            // should be an error. Why? Because both F-->E and F?-->E? are added to the candidate\n            // set. What is SX? Clearly F, because there is a candidate that takes an F.  \n            // What is TX? Clearly E? because there is a candidate that returns an E?.  \n            // And now the overload resolution problem is ambiguous because neither operator\n            // takes SX and returns TX. \n            //\n            // DELIBERATE SPEC VIOLATION:\n            //\n            // The native compiler takes a rather different approach than the approach described\n            // in the specification. Rather than adding both the lifted and unlifted forms of\n            // each operator to the candidate set, using those operators to determine the best\n            // source and target types, and then choosing the unique operator from that source type\n            // to that target type, it instead *transforms in place* the \"from\" and \"to\" types\n            // of each operator so that their nullability matches those of the source and target\n            // types. This can then lead to ambiguities; consider for example a type that\n            // has user defined conversions X-->Y and X-->Y?.  If we have a conversion from X to\n            // Y?, the spec would say that the operators X-->Y, its lifted form X?-->Y?, and\n            // X-->Y? are applicable candidates and that the best of them is X-->Y?.  \n            //\n            // The native compiler arrives at the same conclusion but by different logic; it says\n            // that X-->Y has a \"half lifted\" form X-->Y?, and that it is \"worse\" than X-->Y?\n            // because it is half lifted.\n\n            // Therefore we match this behavior by first checking to see if there is a unique\n            // best operator that converts from the source type to the target type with liftings\n            // on neither side.\n\n            BestIndex bestUnlifted = u.UniqueIndex(\n                conv =>\n                conv.FromType == sx &&\n                conv.ToType == tx &&\n                LiftingCount(conv) == 0);\n\n            if (bestUnlifted.Kind == BestIndexKind.Best)\n            {\n                return bestUnlifted.Best;\n            }\n            else if (bestUnlifted.Kind == BestIndexKind.Ambiguous)\n            {\n                // If we got an ambiguity, don't continue. We need to bail immediately.\n\n                // UNDONE: We can do better error reporting if we return the ambiguity and\n                // use that in the error message.\n                return null;\n            }\n\n            // There was no fully-unlifted operator. Check to see if there was any *half-lifted* operator. \n            //\n            // For example, suppose we had a conversion from X-->Y?, and lifted it to X?-->Y?. (The spec\n            // says not to do such a lifting because Y? is not a non-nullable value type, but the native\n            // compiler does so and we are being compatible with it.) That would be a half-lifted operator.\n            //\n            // For example, suppose we had a conversion from X-->Y, and the assignment Y? y = new X(); --\n            // this would also be a \"half lifted\" conversion even though there is no \"lifting\" going on\n            // (in the sense that we are not checking the source to see if it is null.)\n            // \n\n            BestIndex bestHalfLifted = u.UniqueIndex(\n                conv =>\n                conv.FromType == sx &&\n                conv.ToType == tx &&\n                LiftingCount(conv) == 1);\n\n            if (bestHalfLifted.Kind == BestIndexKind.Best)\n            {\n                return bestHalfLifted.Best;\n            }\n            else if (bestHalfLifted.Kind == BestIndexKind.Ambiguous)\n            {\n                // UNDONE: We can do better error reporting if we return the ambiguity and\n                // use that in the error message.\n                return null;\n            }\n\n            // Finally, see if there is a unique best *fully lifted* operator.\n\n            BestIndex bestFullyLifted = u.UniqueIndex(\n                conv =>\n                conv.FromType == sx &&\n                conv.ToType == tx &&\n                LiftingCount(conv) == 2);\n\n            if (bestFullyLifted.Kind == BestIndexKind.Best)\n            {\n                return bestFullyLifted.Best;\n            }\n            else if (bestFullyLifted.Kind == BestIndexKind.Ambiguous)\n            {\n                // UNDONE: We can do better error reporting if we return the ambiguity and\n                // use that in the error message.\n                return null;\n            }\n\n            return null;\n        }\n\n        // Is A encompassed by B?\n        private bool IsEncompassedBy(BoundExpression aExpr, TypeSymbol a, TypeSymbol b, ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            Debug.Assert((object)a != null);\n            Debug.Assert((object)b != null);\n\n            // SPEC: If a standard implicit conversion exists from a type A to a type B\n            // SPEC: and if neither A nor B is an interface type then A is said to be\n            // SPEC: encompassed by B, and B is said to encompass A.\n\n            return EncompassingImplicitConversion(aExpr, a, b, ref useSiteDiagnostics).Exists;\n        }\n\n        private Conversion EncompassingImplicitConversion(BoundExpression aExpr, TypeSymbol a, TypeSymbol b, ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            Debug.Assert(aExpr != null || (object)a != null);\n            Debug.Assert((object)b != null);\n\n            // DELIBERATE SPEC VIOLATION: \n            // We ought to be saying that an encompassing conversion never exists when one of\n            // the types is an interface type, but due to a desire to be compatible with a \n            // dev10 bug, we allow it. See the comment regarding bug 17021 above for more details.\n\n            var result = ClassifyStandardImplicitConversion(aExpr, a, b, ref useSiteDiagnostics);\n            return IsEncompassingImplicitConversionKind(result.Kind) ? result : Conversion.NoConversion;\n        }\n\n        private static bool IsEncompassingImplicitConversionKind(ConversionKind kind)\n        {\n            switch (kind)\n            {\n                // Doesn't even exist.\n                case ConversionKind.NoConversion:\n\n                // Specifically disallowed because there would be subtle\n                // consequences for the overload betterness rules.\n                case ConversionKind.MethodGroup:\n                case ConversionKind.AnonymousFunction:\n                case ConversionKind.ImplicitDynamic:\n                case ConversionKind.InterpolatedString:\n\n                // DELIBERATE SPEC VIOLATION: \n                // We do not support an encompassing implicit conversion from a zero constant\n                // to an enum type, because the native compiler did not.  It would be a breaking\n                // change.\n                case ConversionKind.ImplicitEnumeration:\n\n                // Not built in.\n                case ConversionKind.ImplicitUserDefined:\n                case ConversionKind.ExplicitUserDefined:\n\n                // Not implicit.\n                case ConversionKind.ExplicitNumeric:\n                case ConversionKind.ExplicitEnumeration:\n                case ConversionKind.ExplicitNullable:\n                case ConversionKind.ExplicitReference:\n                case ConversionKind.Unboxing:\n                case ConversionKind.ExplicitDynamic:\n                case ConversionKind.PointerToPointer:\n                case ConversionKind.PointerToInteger:\n                case ConversionKind.IntegerToPointer:\n                case ConversionKind.IntPtr:\n                    return false;\n\n                // Spec'd in C# 4.\n                case ConversionKind.Identity:\n                case ConversionKind.ImplicitNumeric:\n                case ConversionKind.ImplicitNullable:\n                case ConversionKind.ImplicitReference:\n                case ConversionKind.Boxing:\n                case ConversionKind.ImplicitConstant:\n                case ConversionKind.PointerToVoid:\n\n                // Added to spec in Roslyn timeframe.\n                case ConversionKind.NullLiteral:\n                case ConversionKind.NullToPointer:\n                    return true;\n\n                default:\n                    throw ExceptionUtilities.Unreachable;\n            }\n        }\n\n        private TypeSymbol MostEncompassedType<T>(\n            ImmutableArray<T> items,\n            Func<T, TypeSymbol> extract,\n            ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            return MostEncompassedType<T>(items, x => true, extract, ref useSiteDiagnostics);\n        }\n\n        private TypeSymbol MostEncompassedType<T>(\n            ImmutableArray<T> items,\n            Func<T, bool> valid,\n            Func<T, TypeSymbol> extract,\n            ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n\n            // SPEC: The most encompassed type is the one type in the set that \n            // SPEC: is encompassed by all the other types.\n\n            // We have a bit of a graph theory problem here. Suppose hypothetically\n            // speaking we have three types in the set such that:\n            //\n            // X is encompassed by Y\n            // X is encompassed by Z\n            // Y is encompassed by X\n            //\n            // In that situation, X is the unique type in the set that is encompassed\n            // by all the other types, despite the fact that it appears to be neither\n            // better nor worse than Y! \n            //\n            // But in practice this situation never arises because implicit convertibility\n            // is transitive; if Y is implicitly convertible to X and X is implicitly convertible\n            // to Z, then Y is implicitly convertible to Z.\n            //\n            // Because we have this transitivity, we can rephrase the problem as follows:\n            //\n            // Find the unique best type in the set, where the best type is the type that is \n            // better than every other type. By \"X is better than Y\" we mean \"X is encompassed \n            // by Y but Y is not encompassed by X\".\n\n            HashSet<DiagnosticInfo> _useSiteDiagnostics = useSiteDiagnostics;\n            int? best = items.UniqueBestValidIndex(valid,\n                (left, right) =>\n                {\n                    TypeSymbol leftType = extract(left);\n                    TypeSymbol rightType = extract(right);\n                    if (leftType == rightType)\n                    {\n                        return BetterResult.Equal;\n                    }\n\n                    bool leftWins = IsEncompassedBy(null, leftType, rightType, ref _useSiteDiagnostics);\n                    bool rightWins = IsEncompassedBy(null, rightType, leftType, ref _useSiteDiagnostics);\n                    if (leftWins == rightWins)\n                    {\n                        return BetterResult.Neither;\n                    }\n                    return leftWins ? BetterResult.Left : BetterResult.Right;\n                });\n\n            useSiteDiagnostics = _useSiteDiagnostics;\n            return best == null ? null : extract(items[best.Value]);\n        }\n\n        private TypeSymbol MostEncompassingType<T>(\n            ImmutableArray<T> items,\n            Func<T, TypeSymbol> extract,\n            ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            return MostEncompassingType<T>(items, x => true, extract, ref useSiteDiagnostics);\n        }\n\n\n        private TypeSymbol MostEncompassingType<T>(\n            ImmutableArray<T> items,\n            Func<T, bool> valid,\n            Func<T, TypeSymbol> extract,\n            ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n\n            // See comments above.\n            HashSet<DiagnosticInfo> _useSiteDiagnostics = useSiteDiagnostics;\n            int? best = items.UniqueBestValidIndex(valid,\n                (left, right) =>\n                {\n                    TypeSymbol leftType = extract(left);\n                    TypeSymbol rightType = extract(right);\n                    if (leftType == rightType)\n                    {\n                        return BetterResult.Equal;\n                    }\n\n                    bool leftWins = IsEncompassedBy(null, rightType, leftType, ref _useSiteDiagnostics);\n                    bool rightWins = IsEncompassedBy(null, leftType, rightType, ref _useSiteDiagnostics);\n                    if (leftWins == rightWins)\n                    {\n                        return BetterResult.Neither;\n                    }\n                    return leftWins ? BetterResult.Left : BetterResult.Right;\n                });\n\n            useSiteDiagnostics = _useSiteDiagnostics;\n            return best == null ? null : extract(items[best.Value]);\n        }\n\n        private NamedTypeSymbol MakeNullableType(TypeSymbol type)\n        {\n            var nullable = this.corLibrary.GetDeclaredSpecialType(SpecialType.System_Nullable_T);\n            return nullable.Construct(type);\n        }\n\n        /// <remarks>\n        /// NOTE: Keep this method in sync with AnalyzeImplicitUserDefinedConversion.\n        /// </remarks>\n        protected UserDefinedConversionResult AnalyzeImplicitUserDefinedConversionForSwitchGoverningType(TypeSymbol source, ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            // SPEC:    The governing type of a switch statement is established by the switch expression.\n            // SPEC:    1) If the type of the switch expression is sbyte, byte, short, ushort, int, uint,\n            // SPEC:       long, ulong, bool, char, string, or an enum-type, or if it is the nullable type\n            // SPEC:       corresponding to one of these types, then that is the governing type of the switch statement. \n            // SPEC:    2) Otherwise, exactly one user-defined implicit conversion (ยง6.4) must exist from the\n            // SPEC:       type of the switch expression to one of the following possible governing types:\n            // SPEC:       sbyte, byte, short, ushort, int, uint, long, ulong, char, string, or, a nullable type\n            // SPEC:       corresponding to one of those types\n\n            // NOTE:    This method implements part (2) above, it should be called only if (1) is false for source type.\n            Debug.Assert((object)source != null);\n            Debug.Assert(!source.IsValidSwitchGoverningType());\n\n            // NOTE:    There are multiple possible approaches for implementing (2):\n            // NOTE:    1)  AnalyzeImplicitUserDefinedConversion from source type to each of the possible governing types\n            // NOTE:        mentioned in (2): Though this approach exactly matches the specification, it is highly inefficient.\n            // NOTE:        We need to consider 20 possible target types (ten primitive non-nullable types\n            // NOTE:        and ten primitive nullable types) to determine if there is exactly one valid user defined conversion to\n            // NOTE:        any one of these types, requiring 20 calls to AnalyzeImplicitUserDefinedConversion.\n            // NOTE:    2)  Native compiler's approach: Native compiler implements this by walking through all the implicit user defined operators\n            // NOTE:        from the source type to a valid switch governing type, as per (2), and determining if there is a unique best.\n            // NOTE:        This part is that piece of code doesn't call into the code for analyzing user defined implicit conversion, but does the\n            // NOTE:        analysis of applicable lifted/normal forms itself. This makes it very difficult to maintain and is bug prone.\n            // NOTE:        See the SPEC VIOLATION comment later in this method for one of the cases where it gets the analysis wrong and violates the\n            // NOTE:        language specification.\n            // NOTE:    3)  Use an approach similar to native compiler's approach, but call into the common code for analyzing user defined implicit conversion.\n\n\n            // NOTE:    We choose approach (3) and implement it as a slight variation of AnalyzeImplicitUserDefinedConversion as follows:\n\n            // NOTE:    (a) Compute the set of types D from which user-defined conversion operators should be considered by considering only the source type.\n            // NOTE:    (b) Instead of computing applicable user defined implicit conversions U from the source type to a specific target type,\n            // NOTE:        we compute these from the source type to ANY target type.\n            // NOTE:    (c) If U is empty, the conversion is undefined and a compile-time error occurs.\n            // NOTE:    (d) Find the most specific source type SX of the operators in U...\n            // NOTE:    (e) Instead of finding the most specific target type TX of the operators in U, we consider all unique target types TX for all operators in U.\n            // NOTE:        Let this set of unique target types be called Y.\n            // NOTE:    (f) Check if there is exactly one target type TX in Y such that it satisfied both conditions below:\n            // NOTE:        (i)  TX is a valid switch governing type as per condition (2) of the SPEC for establishing the switch governing type and \n            // NOTE:        (ii) There is a valid most specific user defined implicit conversion operator from SX to TX.\n            // NOTE:        If there exists such unique TX in Y, then that operator is the resultant user defined conversion and TX is the resultant switch governing type.\n            // NOTE:        Otherwise we either have ambiguity or no applicable operators.\n\n            // (a) Compute the set of types D from which user-defined conversion operators should be considered by considering only the source type.\n            var d = ArrayBuilder<NamedTypeSymbol>.GetInstance();\n            ComputeUserDefinedImplicitConversionTypeSet(source, t: null, d: d, useSiteDiagnostics: ref useSiteDiagnostics);\n\n            // (b) Instead of computing applicable user defined implicit conversions U from the source type to a specific target type,\n            //     we compute these from the source type to ANY target type.\n            var ubuild = ArrayBuilder<UserDefinedConversionAnalysis>.GetInstance();\n            ComputeApplicableUserDefinedImplicitConversionSet(null, source, target: null, d: d, u: ubuild, useSiteDiagnostics: ref useSiteDiagnostics, allowAnyTarget: true);\n            d.Free();\n            ImmutableArray<UserDefinedConversionAnalysis> u = ubuild.ToImmutableAndFree();\n\n            // (c) If U is empty, the conversion is undefined and a compile-time error occurs.\n            if (u.Length == 0)\n            {\n                return UserDefinedConversionResult.NoApplicableOperators(u);\n            }\n\n            // (d) Find the most specific source type SX of the operators in U...\n            TypeSymbol sx = MostSpecificSourceTypeForImplicitUserDefinedConversion(u, source, ref useSiteDiagnostics);\n            if ((object)sx == null)\n            {\n                return UserDefinedConversionResult.NoBestSourceType(u);\n            }\n\n            return MostSpecificConversionOperatorForSwitchGoverningType(sx, u);\n        }\n\n        private static UserDefinedConversionResult MostSpecificConversionOperatorForSwitchGoverningType(TypeSymbol sx, ImmutableArray<UserDefinedConversionAnalysis> u)\n        {\n            // This method finds the most specific user-defined implicit conversion operator from the best source type SX to a valid switch governing type.\n            // It implements steps (e) and (f) for AnalyzeImplicitUserDefinedConversionForSwitchGoverningType, see comments in that method for details.\n\n            // (e) Instead of finding the most specific target type TX of the operators in U, we consider all unique target types TX for all operators in U.\n            //     Let this set of unique target types be called Y.\n            var y = new HashSet<TypeSymbol>();\n            UserDefinedConversionResult? exactConversionResult = null;\n\n            // (f) Check if there is exactly one target type TX in Y such that it satisfied both conditions below:\n            //     (i)  TX is a valid switch governing type as per condition (2) of the SPEC for establishing the switch governing type and \n            //     (ii) There is a valid most specific user defined implicit conversion operator from SX to TX.\n\n            foreach (UserDefinedConversionAnalysis analysis in u)\n            {\n                TypeSymbol tx = analysis.ToType;\n\n                if (y.Add(tx) && tx.IsValidSwitchGoverningType(isTargetTypeOfUserDefinedOp: true))\n                {\n                    if (!exactConversionResult.HasValue)\n                    {\n                        // NOTE:    As mentioned in the comments at the start of this function, native compiler doesn't call into\n                        // NOTE:    the code for analyzing user defined implicit conversion, i.e. MostSpecificConversionOperator,\n                        // NOTE:    but does the analysis of applicable lifted/normal forms itself.\n                        // NOTE:    This introduces a SPEC VIOLATION for the following test in the native compiler:\n\n                        // NOTE:    // See test SwitchTests.CS0166_AggregateTypeWithMultipleImplicitConversions_07\n                        // NOTE:    struct Conv\n                        // NOTE:    {\n                        // NOTE:        public static implicit operator int (Conv C) { return 1; }\n                        // NOTE:        public static implicit operator int (Conv? C2) { return 0; }\n                        // NOTE:        public static int Main()\n                        // NOTE:        {\n                        // NOTE:            Conv? D = new Conv();\n                        // NOTE:            switch(D)\n                        // NOTE:            {   ...\n\n                        // SPEC VIOLATION: Native compiler allows the above code to compile\n                        // SPEC VIOLATION: even though there are two user-defined implicit conversions:\n                        // SPEC VIOLATION: 1) To int type (applicable in normal form): public static implicit operator int (Conv? C2)\n                        // SPEC VIOLATION: 2) To int? type (applicable in lifted form): public static implicit operator int (Conv C)\n\n                        // SPEC VIOLATION: We maintain compability with the native compiler.\n\n                        int? best = MostSpecificConversionOperator(sx, tx, u);\n                        if (best != null)\n                        {\n                            exactConversionResult = UserDefinedConversionResult.Valid(u, best.Value);\n                            continue;\n                        }\n                    }\n\n                    return UserDefinedConversionResult.Ambiguous(u);\n                }\n            }\n\n            // If there exists such unique TX in Y, then that operator is the resultant user defined conversion and TX is the resultant switch governing type.\n            // Otherwise we either have ambiguity or no applicable operators.\n\n            return exactConversionResult.HasValue ?\n                exactConversionResult.Value :\n                UserDefinedConversionResult.NoApplicableOperators(u);\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 46464,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable10\\Portable\\Binder\\Semantics\\Conversions\\UserDefinedImplicitConversions.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable10\\Portable\\Binder\\Semantics\\Conversions\\UserDefinedImplicitConversions.cs"
  },
  {
    "Text": "u.UniqueIndex(\n                conv =>",
    "Start": 26418,
    "Length": 38,
    "Parent": {
      "Text": "// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Utilities;\n\nnamespace Microsoft.CodeAnalysis.CSharp\n{\n    internal abstract partial class ConversionsBase\n    {\n        /// <remarks>\n        /// NOTE: Keep this method in sync with AnalyzeImplicitUserDefinedConversionForSwitchGoverningType.\n        /// </remarks>\n        private UserDefinedConversionResult AnalyzeImplicitUserDefinedConversions(\n            BoundExpression sourceExpression,\n            TypeSymbol source,\n            TypeSymbol target,\n            ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            Debug.Assert(sourceExpression != null || (object)source != null);\n            Debug.Assert((object)target != null);\n\n            // User-defined conversions that involve generics can be quite strange. There\n            // are two basic problems: first, that generic user-defined conversions can be\n            // \"shadowed\" by built-in conversions, and second, that generic user-defined\n            // conversions can make conversions that would never have been legal user-defined\n            // conversions if declared non-generically. I call this latter kind of conversion\n            // a \"suspicious\" conversion.\n            //\n            // The shadowed conversions are easily dealt with:\n            //\n            // SPEC: If a predefined implicit conversion exists from a type S to type T,\n            // SPEC: all user-defined conversions, implicit or explicit, are ignored.\n            // SPEC: If a predefined explicit conversion exists from a type S to type T,\n            // SPEC: any user-defined explicit conversion from S to T are ignored.\n            //\n            // The rule above can come into play in cases like:\n            //\n            // sealed class C<T> { public static implicit operator T(C<T> c) { ... } }\n            // C<object> c = whatever;\n            // object o = c;\n            //\n            // The built-in implicit conversion from C<object> to object must shadow\n            // the user-defined implicit conversion.\n            //\n            // The caller of this method checks for user-defined conversions *after*\n            // predefined implicit conversions, so we already know that if we got here,\n            // there was no predefined implicit conversion. \n            //\n            // Note that a user-defined *implicit* conversion may win over a built-in\n            // *explicit* conversion by the rule given above. That is, if we created\n            // an implicit conversion from T to C<T>, then the user-defined implicit \n            // conversion from object to C<object> could be valid, even though that\n            // would be \"replacing\" a built-in explicit conversion with a user-defined\n            // implicit conversion. This is one of the \"suspicious\" conversions,\n            // as it would not be legal to declare a user-defined conversion from\n            // object in a non-generic type.\n            //\n            // The way the native compiler handles suspicious conversions involving\n            // interfaces is neither sensible nor in line with the rules in the \n            // specification. It is not clear at this time whether we should be exactly\n            // matching the native compiler, the specification, or neither, in Roslyn.\n\n            // Spec (6.4.4 User-defined implicit conversions)\n            //   A user-defined implicit conversion from an expression E to type T is processed as follows:\n\n            // SPEC: Find the set of types D from which user-defined conversion operators...\n            var d = ArrayBuilder<NamedTypeSymbol>.GetInstance();\n            ComputeUserDefinedImplicitConversionTypeSet(source, target, d, ref useSiteDiagnostics);\n\n            // SPEC: Find the set of applicable user-defined and lifted conversion operators, U...\n            var ubuild = ArrayBuilder<UserDefinedConversionAnalysis>.GetInstance();\n            ComputeApplicableUserDefinedImplicitConversionSet(sourceExpression, source, target, d, ubuild, ref useSiteDiagnostics);\n            d.Free();\n            ImmutableArray<UserDefinedConversionAnalysis> u = ubuild.ToImmutableAndFree();\n\n            // SPEC: If U is empty, the conversion is undefined and a compile-time error occurs.\n            if (u.Length == 0)\n            {\n                return UserDefinedConversionResult.NoApplicableOperators(u);\n            }\n\n            // SPEC: Find the most specific source type SX of the operators in U...\n            TypeSymbol sx = MostSpecificSourceTypeForImplicitUserDefinedConversion(u, source, ref useSiteDiagnostics);\n            if ((object)sx == null)\n            {\n                return UserDefinedConversionResult.NoBestSourceType(u);\n            }\n\n            // SPEC: Find the most specific target type TX of the operators in U...\n            TypeSymbol tx = MostSpecificTargetTypeForImplicitUserDefinedConversion(u, target, ref useSiteDiagnostics);\n            if ((object)tx == null)\n            {\n                return UserDefinedConversionResult.NoBestTargetType(u);\n            }\n\n            int? best = MostSpecificConversionOperator(sx, tx, u);\n            if (best == null)\n            {\n                return UserDefinedConversionResult.Ambiguous(u);\n            }\n\n            return UserDefinedConversionResult.Valid(u, best.Value);\n        }\n\n        private static void ComputeUserDefinedImplicitConversionTypeSet(TypeSymbol s, TypeSymbol t, ArrayBuilder<NamedTypeSymbol> d, ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            // Spec 6.4.4: User-defined implicit conversions\n            //   Find the set of types D from which user-defined conversion operators\n            //   will be considered. This set consists of S0 (if S0 is a class or struct),\n            //   the base classes of S0 (if S0 is a class), and T0 (if T0 is a class or struct).\n\n            TypeSymbol s0 = GetUnderlyingEffectiveType(s, ref useSiteDiagnostics);\n            TypeSymbol t0 = GetUnderlyingEffectiveType(t, ref useSiteDiagnostics);\n\n            AddTypesParticipatingInUserDefinedConversion(d, s0, includeBaseTypes: true, useSiteDiagnostics: ref useSiteDiagnostics);\n            AddTypesParticipatingInUserDefinedConversion(d, t0, includeBaseTypes: false, useSiteDiagnostics: ref useSiteDiagnostics);\n        }\n\n        /// <summary>\n        /// This method find the set of applicable user-defined and lifted conversion operators, u.\n        /// The set consists of the user-defined and lifted implicit conversion operators declared by\n        /// the classes and structs in d that convert from a type encompassing source to a type encompassed by target.\n        /// However if allowAnyTarget is true, then it considers all operators that convert from a type encompassing source\n        /// to any target. This flag must be set only if we are computing user defined conversions from a given source\n        /// type to any target type.\n        /// </summary>\n        /// <remarks>\n        /// Currently allowAnyTarget flag is only set to true by AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,\n        /// where we must consider user defined implicit conversions from the type of the switch expression to\n        /// any of the possible switch governing types.\n        /// </remarks>\n        private void ComputeApplicableUserDefinedImplicitConversionSet(\n            BoundExpression sourceExpression,\n            TypeSymbol source,\n            TypeSymbol target,\n            ArrayBuilder<NamedTypeSymbol> d,\n            ArrayBuilder<UserDefinedConversionAnalysis> u,\n            ref HashSet<DiagnosticInfo> useSiteDiagnostics,\n            bool allowAnyTarget = false)\n        {\n            Debug.Assert(sourceExpression != null || (object)source != null);\n            Debug.Assert(((object)target != null) == !allowAnyTarget);\n            Debug.Assert(d != null);\n            Debug.Assert(u != null);\n\n            // SPEC: Find the set of applicable user-defined and lifted conversion operators, U.\n            // SPEC: The set consists of the user-defined and lifted implicit conversion operators\n            // SPEC: declared by the classes and structs in D that convert from a type encompassing\n            // SPEC: E to a type encompassed by T. If U is empty, the conversion is undefined and\n            // SPEC: a compile-time error occurs.\n\n            // SPEC: Give a user-defined conversion operator that converts from a non-nullable\n            // SPEC: value type S to a non-nullable value type T, a lifted conversion operator\n            // SPEC: exists that converts from S? to T?.\n\n            // DELIBERATE SPEC VIOLATION:\n            //\n            // The spec here essentially says that we add an applicable \"regular\" conversion and \n            // an applicable lifted conversion, if there is one, to the candidate set, and then\n            // let them duke it out to determine which one is \"best\".\n            //\n            // This is not at all what the native compiler does, and attempting to implement\n            // the specification, or slight variations on it, produces too many backwards-compatibility\n            // breaking changes.\n            //\n            // The native compiler deviates from the specification in two major ways here.\n            // First, it does not add *both* the regular and lifted forms to the candidate set.\n            // Second, the way it characterizes a \"lifted\" form is very, very different from\n            // how the specification characterizes a lifted form. \n            //\n            // An operation, in this case, X-->Y, is properly said to be \"lifted\" to X?-->Y? via\n            // the rule that X?-->Y? matches the behavior of X-->Y for non-null X, and converts\n            // null X to null Y otherwise.\n            //\n            // The native compiler, by contrast, takes the existing operator and \"lifts\" either\n            // the operator's parameter type or the operator's return type to nullable. For\n            // example, a conversion from X?-->Y would be \"lifted\" to X?-->Y? by making the\n            // conversion from X? to Y, and then from Y to Y?.  No \"lifting\" semantics\n            // are imposed; we do not check to see if the X? is null. This operator is not\n            // actually \"lifted\" at all; rather, an implicit conversion is applied to the \n            // output. **The native compiler considers the result type Y? of that standard implicit\n            // conversion to be the result type of the \"lifted\" conversion**, rather than\n            // properly considering Y to be the result type of the conversion for the purposes \n            // of computing the best output type.\n            //\n            // MOREOVER: the native compiler actually *does* implement nullable lifting semantics\n            // in the case where the input type of the user-defined conversion is a non-nullable\n            // value type and the output type is a nullable value type **or pointer type, or \n            // reference type**. This is an enormous departure from the specification; the\n            // native compiler will take a user-defined conversion from X-->Y? or X-->C and \"lift\"\n            // it to a conversion from X?-->Y? or X?-->C that has nullable semantics.\n            // \n            // This is quite confusing. In this code we will classify the conversion as either\n            // \"normal\" or \"lifted\" on the basis of *whether or not special lifting semantics\n            // are to be applied*. That is, whether or not a later rewriting pass is going to\n            // need to insert a check to see if the source expression is null, and decide\n            // whether or not to call the underlying unlifted conversion or produce a null\n            // value without calling the unlifted conversion.\n\n            // DELIBERATE SPEC VIOLATION (See bug 17021)\n            // The specification defines a type U as \"encompassing\" a type V\n            // if there is a standard implicit conversion from U to V, and\n            // neither are interface types.\n            //\n            // The intention of this language is to ensure that we do not allow user-defined\n            // conversions that involve interfaces. We have a reasonable expectation that a\n            // conversion that involves an interface is one that preserves referential identity,\n            // and user-defined conversions usually do not.\n            //\n            // Now, suppose we have a standard conversion from Alpha to Beta, a user-defined\n            // conversion from Beta to Gamma, and a standard conversion from Gamma to Delta.\n            // The specification allows the implicit conversion from Alpha to Delta only if \n            // Beta encompasses Alpha and Delta encompasses Gamma.  And therefore, none of them\n            // can be interface types, de jure.\n            //\n            // However, the dev10 compiler only checks Alpha and Delta to see if they are interfaces,\n            // and allows Beta and Gamma to be interfaces. \n            //\n            // So what's the big deal there? It's not legal to define a user-defined conversion where\n            // the input or output types are interfaces, right?\n            //\n            // It is not legal to define such a conversion, no, but it is legal to create one via generic\n            // construction. If we have a conversion from T to C<T>, then C<I> has a conversion from I to C<I>.\n            //\n            // The dev10 compiler fails to check for this situation. This means that, \n            // you can convert from int to C<IComparable> because int implements IComparable, but cannot\n            // convert from IComparable to C<IComparable>!\n            //\n            // Unfortunately, we know of several real programs that rely upon this bug, so we are going\n            // to reproduce it here.\n\n            if ((object)source != null && source.IsInterfaceType() || (object)target != null && target.IsInterfaceType())\n            {\n                return;\n            }\n\n            foreach (NamedTypeSymbol declaringType in d)\n            {\n                foreach (MethodSymbol op in declaringType.GetOperators(WellKnownMemberNames.ImplicitConversionName))\n                {\n                    // We might have a bad operator and be in an error recovery situation. Ignore it.\n                    if (op.ReturnsVoid || op.ParameterCount != 1)\n                    {\n                        continue;\n                    }\n\n                    TypeSymbol convertsFrom = op.ParameterTypes[0];\n                    TypeSymbol convertsTo = op.ReturnType;\n                    Conversion fromConversion = EncompassingImplicitConversion(sourceExpression, source, convertsFrom, ref useSiteDiagnostics);\n                    Conversion toConversion = allowAnyTarget ? Conversion.Identity :\n                        EncompassingImplicitConversion(null, convertsTo, target, ref useSiteDiagnostics);\n\n                    if (fromConversion.Exists && toConversion.Exists)\n                    {\n                        // There is an additional spec violation in the native compiler. Suppose\n                        // we have a conversion from X-->Y and are asked to do \"Y? y = new X();\"  Clearly\n                        // the intention is to convert from X-->Y via the implicit conversion, and then\n                        // stick a standard implicit conversion from Y-->Y? on the back end. **In this \n                        // situation, the native compiler treats the conversion as though it were\n                        // actually X-->Y? in source for the purposes of determining the best target\n                        // type of an operator.\n                        //\n                        // We perpetuate this fiction here.\n\n                        if ((object)target != null && target.IsNullableType() && convertsTo.IsNonNullableValueType())\n                        {\n                            convertsTo = MakeNullableType(convertsTo);\n                            toConversion = allowAnyTarget ? Conversion.Identity :\n                                EncompassingImplicitConversion(null, convertsTo, target, ref useSiteDiagnostics);\n                        }\n\n                        u.Add(UserDefinedConversionAnalysis.Normal(op, fromConversion, toConversion, convertsFrom, convertsTo));\n                    }\n                    else if ((object)source != null && (object)target != null && source.IsNullableType() && convertsFrom.IsNonNullableValueType() && target.CanBeAssignedNull())\n                    {\n                        // As mentioned above, here we diverge from the specification, in two ways.\n                        // First, we only check for the lifted form if the normal form was inapplicable.\n                        // Second, we are supposed to apply lifting semantics only if the conversion \n                        // parameter and return types are *both* non-nullable value types.\n                        //\n                        // In fact the native compiler determines whether to check for a lifted form on\n                        // the basis of:\n                        //\n                        // * Is the type we are ultimately converting from a nullable value type?\n                        // * Is the parameter type of the conversion a non-nullable value type?\n                        // * Is the type we are ultimately converting to a nullable value type, \n                        //   pointer type, or reference type?\n                        //\n                        // If the answer to all those questions is \"yes\" then we lift to nullable\n                        // and see if the resulting operator is applicable.\n                        TypeSymbol nullableFrom = MakeNullableType(convertsFrom);\n                        TypeSymbol nullableTo = convertsTo.IsNonNullableValueType() ? MakeNullableType(convertsTo) : convertsTo;\n                        Conversion liftedFromConversion = EncompassingImplicitConversion(sourceExpression, source, nullableFrom, ref useSiteDiagnostics);\n                        Conversion liftedToConversion = !allowAnyTarget ?\n                            EncompassingImplicitConversion(null, nullableTo, target, ref useSiteDiagnostics) :\n                            Conversion.Identity;\n                        if (liftedFromConversion.Exists && liftedToConversion.Exists)\n                        {\n                            u.Add(UserDefinedConversionAnalysis.Lifted(op, liftedFromConversion, liftedToConversion, nullableFrom, nullableTo));\n                        }\n                    }\n                }\n            }\n        }\n\n        private TypeSymbol MostSpecificSourceTypeForImplicitUserDefinedConversion(ImmutableArray<UserDefinedConversionAnalysis> u, TypeSymbol source, ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            // SPEC: If any of the operators in U convert from S then SX is S.\n            if ((object)source != null)\n            {\n                if (u.Any(conv => conv.FromType == source))\n                {\n                    return source;\n                }\n            }\n\n            // SPEC: Otherwise, SX is the most encompassed type in the set of\n            // SPEC: source types of the operators in U.\n            return MostEncompassedType(u, conv => conv.FromType, ref useSiteDiagnostics);\n        }\n\n        private TypeSymbol MostSpecificTargetTypeForImplicitUserDefinedConversion(ImmutableArray<UserDefinedConversionAnalysis> u, TypeSymbol target, ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            // SPEC: If any of the operators in U convert to T then TX is T.\n            // SPEC: Otherwise, TX is the most encompassing type in the set of\n            // SPEC: target types of the operators in U. \n\n            // DELIBERATE SPEC VIOLATION:\n            // The native compiler deviates from the specification in the way it \n            // determines what the \"converts to\" type is. The specification is pretty\n            // clear that the \"converts to\" type is the actual return type of the \n            // conversion operator, or, in the case of a lifted operator, the lifted-to-\n            // nullable type. That is, if we have X-->Y then the converts-to type of\n            // the operator in its normal form is Y, and the converts-to type of the \n            // operator in its lifted form is Y?. \n            //\n            // The native compiler does not do this. Suppose we have a user-defined\n            // conversion X-->Y, and the assignment Y? y = new X(); -- the native \n            // compiler will consider the converts-to type of X-->Y to be Y?, surprisingly\n            // enough. \n            //\n            // We have previously written the appropriate \"ToType\" into the conversion analysis\n            // to perpetuate this fiction.\n\n            if (u.Any(conv => conv.ToType == target))\n            {\n                return target;\n            }\n\n            return MostEncompassingType(u, conv => conv.ToType, ref useSiteDiagnostics);\n        }\n\n        private static int LiftingCount(UserDefinedConversionAnalysis conv)\n        {\n            int count = 0;\n            if (conv.FromType != conv.Operator.ParameterTypes[0])\n            {\n                count += 1;\n            }\n\n            if (conv.ToType != conv.Operator.ReturnType)\n            {\n                count += 1;\n            }\n\n            return count;\n        }\n\n        private static int? MostSpecificConversionOperator(TypeSymbol sx, TypeSymbol tx, ImmutableArray<UserDefinedConversionAnalysis> u)\n        {\n            Debug.Assert((object)sx != null);\n            Debug.Assert((object)tx != null);\n\n            // SPEC: If U contains exactly one user-defined conversion operator from SX to TX \n            // SPEC: then that is the most-specific conversion operator;\n            //\n            // SPEC: Otherise, if U contains exactly one lifted conversion operator that converts from\n            // SPEC: SX to TX then this is the most specific operator.\n            //\n            // SPEC: Otherise, the conversion is ambiguous and a compile-time error occurs.\n            //\n            // SPEC ERROR:\n            //\n            // Clearly the text above cannot be correct because it gives undesirable results.\n            // Suppose we have structs E and F with an implicit user defined conversion from \n            // F to E. We have an assignment from F to E?. Clearly what should happen is\n            // we should convert F to E, then convert E to E?.  But the spec says that this\n            // should be an error. Why? Because both F-->E and F?-->E? are added to the candidate\n            // set. What is SX? Clearly F, because there is a candidate that takes an F.  \n            // What is TX? Clearly E? because there is a candidate that returns an E?.  \n            // And now the overload resolution problem is ambiguous because neither operator\n            // takes SX and returns TX. \n            //\n            // DELIBERATE SPEC VIOLATION:\n            //\n            // The native compiler takes a rather different approach than the approach described\n            // in the specification. Rather than adding both the lifted and unlifted forms of\n            // each operator to the candidate set, using those operators to determine the best\n            // source and target types, and then choosing the unique operator from that source type\n            // to that target type, it instead *transforms in place* the \"from\" and \"to\" types\n            // of each operator so that their nullability matches those of the source and target\n            // types. This can then lead to ambiguities; consider for example a type that\n            // has user defined conversions X-->Y and X-->Y?.  If we have a conversion from X to\n            // Y?, the spec would say that the operators X-->Y, its lifted form X?-->Y?, and\n            // X-->Y? are applicable candidates and that the best of them is X-->Y?.  \n            //\n            // The native compiler arrives at the same conclusion but by different logic; it says\n            // that X-->Y has a \"half lifted\" form X-->Y?, and that it is \"worse\" than X-->Y?\n            // because it is half lifted.\n\n            // Therefore we match this behavior by first checking to see if there is a unique\n            // best operator that converts from the source type to the target type with liftings\n            // on neither side.\n\n            BestIndex bestUnlifted = u.UniqueIndex(\n                conv =>\n                conv.FromType == sx &&\n                conv.ToType == tx &&\n                LiftingCount(conv) == 0);\n\n            if (bestUnlifted.Kind == BestIndexKind.Best)\n            {\n                return bestUnlifted.Best;\n            }\n            else if (bestUnlifted.Kind == BestIndexKind.Ambiguous)\n            {\n                // If we got an ambiguity, don't continue. We need to bail immediately.\n\n                // UNDONE: We can do better error reporting if we return the ambiguity and\n                // use that in the error message.\n                return null;\n            }\n\n            // There was no fully-unlifted operator. Check to see if there was any *half-lifted* operator. \n            //\n            // For example, suppose we had a conversion from X-->Y?, and lifted it to X?-->Y?. (The spec\n            // says not to do such a lifting because Y? is not a non-nullable value type, but the native\n            // compiler does so and we are being compatible with it.) That would be a half-lifted operator.\n            //\n            // For example, suppose we had a conversion from X-->Y, and the assignment Y? y = new X(); --\n            // this would also be a \"half lifted\" conversion even though there is no \"lifting\" going on\n            // (in the sense that we are not checking the source to see if it is null.)\n            // \n\n            BestIndex bestHalfLifted = u.UniqueIndex(\n                conv =>\n                conv.FromType == sx &&\n                conv.ToType == tx &&\n                LiftingCount(conv) == 1);\n\n            if (bestHalfLifted.Kind == BestIndexKind.Best)\n            {\n                return bestHalfLifted.Best;\n            }\n            else if (bestHalfLifted.Kind == BestIndexKind.Ambiguous)\n            {\n                // UNDONE: We can do better error reporting if we return the ambiguity and\n                // use that in the error message.\n                return null;\n            }\n\n            // Finally, see if there is a unique best *fully lifted* operator.\n\n            BestIndex bestFullyLifted = u.UniqueIndex(\n                conv =>\n                conv.FromType == sx &&\n                conv.ToType == tx &&\n                LiftingCount(conv) == 2);\n\n            if (bestFullyLifted.Kind == BestIndexKind.Best)\n            {\n                return bestFullyLifted.Best;\n            }\n            else if (bestFullyLifted.Kind == BestIndexKind.Ambiguous)\n            {\n                // UNDONE: We can do better error reporting if we return the ambiguity and\n                // use that in the error message.\n                return null;\n            }\n\n            return null;\n        }\n\n        // Is A encompassed by B?\n        private bool IsEncompassedBy(BoundExpression aExpr, TypeSymbol a, TypeSymbol b, ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            Debug.Assert((object)a != null);\n            Debug.Assert((object)b != null);\n\n            // SPEC: If a standard implicit conversion exists from a type A to a type B\n            // SPEC: and if neither A nor B is an interface type then A is said to be\n            // SPEC: encompassed by B, and B is said to encompass A.\n\n            return EncompassingImplicitConversion(aExpr, a, b, ref useSiteDiagnostics).Exists;\n        }\n\n        private Conversion EncompassingImplicitConversion(BoundExpression aExpr, TypeSymbol a, TypeSymbol b, ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            Debug.Assert(aExpr != null || (object)a != null);\n            Debug.Assert((object)b != null);\n\n            // DELIBERATE SPEC VIOLATION: \n            // We ought to be saying that an encompassing conversion never exists when one of\n            // the types is an interface type, but due to a desire to be compatible with a \n            // dev10 bug, we allow it. See the comment regarding bug 17021 above for more details.\n\n            var result = ClassifyStandardImplicitConversion(aExpr, a, b, ref useSiteDiagnostics);\n            return IsEncompassingImplicitConversionKind(result.Kind) ? result : Conversion.NoConversion;\n        }\n\n        private static bool IsEncompassingImplicitConversionKind(ConversionKind kind)\n        {\n            switch (kind)\n            {\n                // Doesn't even exist.\n                case ConversionKind.NoConversion:\n\n                // Specifically disallowed because there would be subtle\n                // consequences for the overload betterness rules.\n                case ConversionKind.MethodGroup:\n                case ConversionKind.AnonymousFunction:\n                case ConversionKind.ImplicitDynamic:\n                case ConversionKind.InterpolatedString:\n\n                // DELIBERATE SPEC VIOLATION: \n                // We do not support an encompassing implicit conversion from a zero constant\n                // to an enum type, because the native compiler did not.  It would be a breaking\n                // change.\n                case ConversionKind.ImplicitEnumeration:\n\n                // Not built in.\n                case ConversionKind.ImplicitUserDefined:\n                case ConversionKind.ExplicitUserDefined:\n\n                // Not implicit.\n                case ConversionKind.ExplicitNumeric:\n                case ConversionKind.ExplicitEnumeration:\n                case ConversionKind.ExplicitNullable:\n                case ConversionKind.ExplicitReference:\n                case ConversionKind.Unboxing:\n                case ConversionKind.ExplicitDynamic:\n                case ConversionKind.PointerToPointer:\n                case ConversionKind.PointerToInteger:\n                case ConversionKind.IntegerToPointer:\n                case ConversionKind.IntPtr:\n                    return false;\n\n                // Spec'd in C# 4.\n                case ConversionKind.Identity:\n                case ConversionKind.ImplicitNumeric:\n                case ConversionKind.ImplicitNullable:\n                case ConversionKind.ImplicitReference:\n                case ConversionKind.Boxing:\n                case ConversionKind.ImplicitConstant:\n                case ConversionKind.PointerToVoid:\n\n                // Added to spec in Roslyn timeframe.\n                case ConversionKind.NullLiteral:\n                case ConversionKind.NullToPointer:\n                    return true;\n\n                default:\n                    throw ExceptionUtilities.Unreachable;\n            }\n        }\n\n        private TypeSymbol MostEncompassedType<T>(\n            ImmutableArray<T> items,\n            Func<T, TypeSymbol> extract,\n            ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            return MostEncompassedType<T>(items, x => true, extract, ref useSiteDiagnostics);\n        }\n\n        private TypeSymbol MostEncompassedType<T>(\n            ImmutableArray<T> items,\n            Func<T, bool> valid,\n            Func<T, TypeSymbol> extract,\n            ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n\n            // SPEC: The most encompassed type is the one type in the set that \n            // SPEC: is encompassed by all the other types.\n\n            // We have a bit of a graph theory problem here. Suppose hypothetically\n            // speaking we have three types in the set such that:\n            //\n            // X is encompassed by Y\n            // X is encompassed by Z\n            // Y is encompassed by X\n            //\n            // In that situation, X is the unique type in the set that is encompassed\n            // by all the other types, despite the fact that it appears to be neither\n            // better nor worse than Y! \n            //\n            // But in practice this situation never arises because implicit convertibility\n            // is transitive; if Y is implicitly convertible to X and X is implicitly convertible\n            // to Z, then Y is implicitly convertible to Z.\n            //\n            // Because we have this transitivity, we can rephrase the problem as follows:\n            //\n            // Find the unique best type in the set, where the best type is the type that is \n            // better than every other type. By \"X is better than Y\" we mean \"X is encompassed \n            // by Y but Y is not encompassed by X\".\n\n            HashSet<DiagnosticInfo> _useSiteDiagnostics = useSiteDiagnostics;\n            int? best = items.UniqueBestValidIndex(valid,\n                (left, right) =>\n                {\n                    TypeSymbol leftType = extract(left);\n                    TypeSymbol rightType = extract(right);\n                    if (leftType == rightType)\n                    {\n                        return BetterResult.Equal;\n                    }\n\n                    bool leftWins = IsEncompassedBy(null, leftType, rightType, ref _useSiteDiagnostics);\n                    bool rightWins = IsEncompassedBy(null, rightType, leftType, ref _useSiteDiagnostics);\n                    if (leftWins == rightWins)\n                    {\n                        return BetterResult.Neither;\n                    }\n                    return leftWins ? BetterResult.Left : BetterResult.Right;\n                });\n\n            useSiteDiagnostics = _useSiteDiagnostics;\n            return best == null ? null : extract(items[best.Value]);\n        }\n\n        private TypeSymbol MostEncompassingType<T>(\n            ImmutableArray<T> items,\n            Func<T, TypeSymbol> extract,\n            ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            return MostEncompassingType<T>(items, x => true, extract, ref useSiteDiagnostics);\n        }\n\n\n        private TypeSymbol MostEncompassingType<T>(\n            ImmutableArray<T> items,\n            Func<T, bool> valid,\n            Func<T, TypeSymbol> extract,\n            ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n\n            // See comments above.\n            HashSet<DiagnosticInfo> _useSiteDiagnostics = useSiteDiagnostics;\n            int? best = items.UniqueBestValidIndex(valid,\n                (left, right) =>\n                {\n                    TypeSymbol leftType = extract(left);\n                    TypeSymbol rightType = extract(right);\n                    if (leftType == rightType)\n                    {\n                        return BetterResult.Equal;\n                    }\n\n                    bool leftWins = IsEncompassedBy(null, rightType, leftType, ref _useSiteDiagnostics);\n                    bool rightWins = IsEncompassedBy(null, leftType, rightType, ref _useSiteDiagnostics);\n                    if (leftWins == rightWins)\n                    {\n                        return BetterResult.Neither;\n                    }\n                    return leftWins ? BetterResult.Left : BetterResult.Right;\n                });\n\n            useSiteDiagnostics = _useSiteDiagnostics;\n            return best == null ? null : extract(items[best.Value]);\n        }\n\n        private NamedTypeSymbol MakeNullableType(TypeSymbol type)\n        {\n            var nullable = this.corLibrary.GetDeclaredSpecialType(SpecialType.System_Nullable_T);\n            return nullable.Construct(type);\n        }\n\n        /// <remarks>\n        /// NOTE: Keep this method in sync with AnalyzeImplicitUserDefinedConversion.\n        /// </remarks>\n        protected UserDefinedConversionResult AnalyzeImplicitUserDefinedConversionForSwitchGoverningType(TypeSymbol source, ref HashSet<DiagnosticInfo> useSiteDiagnostics)\n        {\n            // SPEC:    The governing type of a switch statement is established by the switch expression.\n            // SPEC:    1) If the type of the switch expression is sbyte, byte, short, ushort, int, uint,\n            // SPEC:       long, ulong, bool, char, string, or an enum-type, or if it is the nullable type\n            // SPEC:       corresponding to one of these types, then that is the governing type of the switch statement. \n            // SPEC:    2) Otherwise, exactly one user-defined implicit conversion (ยง6.4) must exist from the\n            // SPEC:       type of the switch expression to one of the following possible governing types:\n            // SPEC:       sbyte, byte, short, ushort, int, uint, long, ulong, char, string, or, a nullable type\n            // SPEC:       corresponding to one of those types\n\n            // NOTE:    This method implements part (2) above, it should be called only if (1) is false for source type.\n            Debug.Assert((object)source != null);\n            Debug.Assert(!source.IsValidSwitchGoverningType());\n\n            // NOTE:    There are multiple possible approaches for implementing (2):\n            // NOTE:    1)  AnalyzeImplicitUserDefinedConversion from source type to each of the possible governing types\n            // NOTE:        mentioned in (2): Though this approach exactly matches the specification, it is highly inefficient.\n            // NOTE:        We need to consider 20 possible target types (ten primitive non-nullable types\n            // NOTE:        and ten primitive nullable types) to determine if there is exactly one valid user defined conversion to\n            // NOTE:        any one of these types, requiring 20 calls to AnalyzeImplicitUserDefinedConversion.\n            // NOTE:    2)  Native compiler's approach: Native compiler implements this by walking through all the implicit user defined operators\n            // NOTE:        from the source type to a valid switch governing type, as per (2), and determining if there is a unique best.\n            // NOTE:        This part is that piece of code doesn't call into the code for analyzing user defined implicit conversion, but does the\n            // NOTE:        analysis of applicable lifted/normal forms itself. This makes it very difficult to maintain and is bug prone.\n            // NOTE:        See the SPEC VIOLATION comment later in this method for one of the cases where it gets the analysis wrong and violates the\n            // NOTE:        language specification.\n            // NOTE:    3)  Use an approach similar to native compiler's approach, but call into the common code for analyzing user defined implicit conversion.\n\n\n            // NOTE:    We choose approach (3) and implement it as a slight variation of AnalyzeImplicitUserDefinedConversion as follows:\n\n            // NOTE:    (a) Compute the set of types D from which user-defined conversion operators should be considered by considering only the source type.\n            // NOTE:    (b) Instead of computing applicable user defined implicit conversions U from the source type to a specific target type,\n            // NOTE:        we compute these from the source type to ANY target type.\n            // NOTE:    (c) If U is empty, the conversion is undefined and a compile-time error occurs.\n            // NOTE:    (d) Find the most specific source type SX of the operators in U...\n            // NOTE:    (e) Instead of finding the most specific target type TX of the operators in U, we consider all unique target types TX for all operators in U.\n            // NOTE:        Let this set of unique target types be called Y.\n            // NOTE:    (f) Check if there is exactly one target type TX in Y such that it satisfied both conditions below:\n            // NOTE:        (i)  TX is a valid switch governing type as per condition (2) of the SPEC for establishing the switch governing type and \n            // NOTE:        (ii) There is a valid most specific user defined implicit conversion operator from SX to TX.\n            // NOTE:        If there exists such unique TX in Y, then that operator is the resultant user defined conversion and TX is the resultant switch governing type.\n            // NOTE:        Otherwise we either have ambiguity or no applicable operators.\n\n            // (a) Compute the set of types D from which user-defined conversion operators should be considered by considering only the source type.\n            var d = ArrayBuilder<NamedTypeSymbol>.GetInstance();\n            ComputeUserDefinedImplicitConversionTypeSet(source, t: null, d: d, useSiteDiagnostics: ref useSiteDiagnostics);\n\n            // (b) Instead of computing applicable user defined implicit conversions U from the source type to a specific target type,\n            //     we compute these from the source type to ANY target type.\n            var ubuild = ArrayBuilder<UserDefinedConversionAnalysis>.GetInstance();\n            ComputeApplicableUserDefinedImplicitConversionSet(null, source, target: null, d: d, u: ubuild, useSiteDiagnostics: ref useSiteDiagnostics, allowAnyTarget: true);\n            d.Free();\n            ImmutableArray<UserDefinedConversionAnalysis> u = ubuild.ToImmutableAndFree();\n\n            // (c) If U is empty, the conversion is undefined and a compile-time error occurs.\n            if (u.Length == 0)\n            {\n                return UserDefinedConversionResult.NoApplicableOperators(u);\n            }\n\n            // (d) Find the most specific source type SX of the operators in U...\n            TypeSymbol sx = MostSpecificSourceTypeForImplicitUserDefinedConversion(u, source, ref useSiteDiagnostics);\n            if ((object)sx == null)\n            {\n                return UserDefinedConversionResult.NoBestSourceType(u);\n            }\n\n            return MostSpecificConversionOperatorForSwitchGoverningType(sx, u);\n        }\n\n        private static UserDefinedConversionResult MostSpecificConversionOperatorForSwitchGoverningType(TypeSymbol sx, ImmutableArray<UserDefinedConversionAnalysis> u)\n        {\n            // This method finds the most specific user-defined implicit conversion operator from the best source type SX to a valid switch governing type.\n            // It implements steps (e) and (f) for AnalyzeImplicitUserDefinedConversionForSwitchGoverningType, see comments in that method for details.\n\n            // (e) Instead of finding the most specific target type TX of the operators in U, we consider all unique target types TX for all operators in U.\n            //     Let this set of unique target types be called Y.\n            var y = new HashSet<TypeSymbol>();\n            UserDefinedConversionResult? exactConversionResult = null;\n\n            // (f) Check if there is exactly one target type TX in Y such that it satisfied both conditions below:\n            //     (i)  TX is a valid switch governing type as per condition (2) of the SPEC for establishing the switch governing type and \n            //     (ii) There is a valid most specific user defined implicit conversion operator from SX to TX.\n\n            foreach (UserDefinedConversionAnalysis analysis in u)\n            {\n                TypeSymbol tx = analysis.ToType;\n\n                if (y.Add(tx) && tx.IsValidSwitchGoverningType(isTargetTypeOfUserDefinedOp: true))\n                {\n                    if (!exactConversionResult.HasValue)\n                    {\n                        // NOTE:    As mentioned in the comments at the start of this function, native compiler doesn't call into\n                        // NOTE:    the code for analyzing user defined implicit conversion, i.e. MostSpecificConversionOperator,\n                        // NOTE:    but does the analysis of applicable lifted/normal forms itself.\n                        // NOTE:    This introduces a SPEC VIOLATION for the following test in the native compiler:\n\n                        // NOTE:    // See test SwitchTests.CS0166_AggregateTypeWithMultipleImplicitConversions_07\n                        // NOTE:    struct Conv\n                        // NOTE:    {\n                        // NOTE:        public static implicit operator int (Conv C) { return 1; }\n                        // NOTE:        public static implicit operator int (Conv? C2) { return 0; }\n                        // NOTE:        public static int Main()\n                        // NOTE:        {\n                        // NOTE:            Conv? D = new Conv();\n                        // NOTE:            switch(D)\n                        // NOTE:            {   ...\n\n                        // SPEC VIOLATION: Native compiler allows the above code to compile\n                        // SPEC VIOLATION: even though there are two user-defined implicit conversions:\n                        // SPEC VIOLATION: 1) To int type (applicable in normal form): public static implicit operator int (Conv? C2)\n                        // SPEC VIOLATION: 2) To int? type (applicable in lifted form): public static implicit operator int (Conv C)\n\n                        // SPEC VIOLATION: We maintain compability with the native compiler.\n\n                        int? best = MostSpecificConversionOperator(sx, tx, u);\n                        if (best != null)\n                        {\n                            exactConversionResult = UserDefinedConversionResult.Valid(u, best.Value);\n                            continue;\n                        }\n                    }\n\n                    return UserDefinedConversionResult.Ambiguous(u);\n                }\n            }\n\n            // If there exists such unique TX in Y, then that operator is the resultant user defined conversion and TX is the resultant switch governing type.\n            // Otherwise we either have ambiguity or no applicable operators.\n\n            return exactConversionResult.HasValue ?\n                exactConversionResult.Value :\n                UserDefinedConversionResult.NoApplicableOperators(u);\n        }\n    }\n}\n",
      "Start": 0,
      "Length": 46464,
      "Parent": null,
      "Node": null,
      "Color": "White",
      "Path": "..\\..\\TestProjects\\Projects\\Portable10\\Portable\\Binder\\Semantics\\Conversions\\UserDefinedImplicitConversions.cs"
    },
    "Node": null,
    "Color": "LightGreen",
    "Path": "..\\..\\TestProjects\\Projects\\Portable10\\Portable\\Binder\\Semantics\\Conversions\\UserDefinedImplicitConversions.cs"
  }
]